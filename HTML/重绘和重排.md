# 重绘 和 重排

  重绘 (Repaint): `重新绘制`, 重绘是当节点需要更改外观⽽不会影响布局的(当前页面中的元素不脱离文档流，而简单的进行样式的变化)，⽐如改变 color 浏览器重新绘制样式, 就叫称为重绘;

  重排 (也可以称为 `回流` Reflow): `重新排列`, 当 布局 或者 ⼏何属性改变 (处于文档流中DOM的尺寸大小、位置或者某些属性发生变化时) 导致浏览器重新渲染部分或者全部文档, 需要进行 重新排列;

  重排必定会发⽣重绘，重绘不⼀定会引发重排。重排所需的成本⽐重绘⾼的多，改变⽗节点⾥的⼦节点很可能会导致⽗节点的⼀系列重排。

## 重绘 和 重排 带来的影响

  重排和重绘会`破坏用户体验`，并且让 UI 展示非常迟缓, 重排 比 重绘 消耗性能开支更大, 一些属性的读取也会引起重排, 比如读取某个 DOM 的高
    
  度和宽度, 或者使用 getComputedStyle 方法。在两者无法避免的情况下, 一般我们选择代价更小的重绘。

## 减少 重绘 和 重排

* 使⽤ translate 替代 top
* 使⽤ visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流 （改变了布局）
* 不要使⽤ table 布局，可能很⼩的⼀个⼩改动会造成整个 table 的重新布局
* 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使⽤ requestAnimationFrame
* CSS 选择符从右往左匹配查找，避免 DOM 深度过深 
* 将频繁运⾏的动画变为图层，图层能够阻⽌该节点回流影响别的元素。⽐如对于 video 标签，浏览器会⾃动将该节点变为图层
* 集中改变样式，不要一条一条地修改 DOM 的样式
* 不要把 DOM 结点的属性值放在循环里当成循环里的变量

```
createDocumentFragment 批量操作 DOM
createDocumentFragment()方法创建了一虚拟的节点对象，节点对象包含所有属性和方法。
通过 createDocumentFragment 创建文档片段，将元素附加到文档片段，然后将文档片段附加到DOM树。在DOM树中，文档片段被其所有的子元素所代替。
因为`文档片段存在于内存中`，并不在 DOM 树中，所以将子元素插入到文档片段时不会引起页面回流。因此，使用文档片段通常会带来更好的性能

```

* 提升为合成层

我们使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。

```

将元素提升为合成层有以下优点：

合成层的位图，会交由 GPU 合成，比 CPU 处理要快
当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层
对于 transform 和 opacity 效果，不会触发 layout 和 paint

强制使用hack方式创建layer并不是长久之计，创建layer的技术可以使页面加速, 但是也有代价：它们占用RAM和GPU存储空间（考虑到移动设备的存储容量有限）

提升合成层的最好方式是使用 CSS 的 will-change 属性：

#target {
  will-change: transform;
}

```

   一个task(宏任务)--队列中全部job(微任务)--requestAnimationFrame--浏览器重排/重绘--requestIdleCallback